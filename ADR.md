# Технічні рішення мікросервісу

Документ описує обґрунтований вибір технологій і фреймворків, використаних у розробці Python-мікросервісу.  
Мета — забезпечити високу продуктивність, масштабованість та простоту підтримки.

---

## Зміст

1. [Рішення: FastAPI для розробки API сервісу](#рішення-fastapi-для-розробки-api-сервісу)  
2. [Рішення: Postgres, як основна база даних](#рішення-postgres-як-основна-база-даних)  
3. [Рішення: Redis для кешування та управління сесіями](#рішення-redis-для-кешування-та-управління-сесіями)  
4. [Рішення: SQLAlchemy для ORM](#рішення-sqlalchemy-для-orm)
5. [Рішення: Pydantic для валідації даних](#рішення-pydantic-для-валідації-даних)
6. [Рішення: aioprometheus для моніторингу](#рішення-aioprometheus-для-моніторингу)  
7. [Рішення: csv.DictReader для обробки CSV файлів](#рішення-csvdictreader-для-обробки-csv-файлів)  
8. [Рішення: Pytest для тестування](#рішення-pytest-для-тестування)  
9. [Рішення: Docker Compose для розгортання](#рішення-docker-compose-для-розгортання)  
10. [Рішення: JWT для аутентифікації](#рішення-jwt-для-аутентифікації)
11. [Рішення: Makefile для автоматизації завдань](#рішення-makefile-для-автоматизації-завдань)
12. [Рішення: logging для структурованого логування](#рішення-logging-для-структурованого-логування)

---

## Рішення: FastAPI для розробки API сервісу

### Контекст
Необхідно обрати фреймворк для розробки API сервісу на Python.  
Важливі критерії: продуктивність, простота використання, підтримка асинхронності, екосистема бібліотек.

### Варіанти

#### Flask
**Плюси:**
- Простота використання та налаштування.
- Велика кількість розширень.
- Підходить для невеликих проєктів.

**Мінуси:**
- Обмежена підтримка асинхронності.
- Менша продуктивність.
- Слабша підтримка сучасних API-стандартів.

#### Django REST Framework
**Плюси:**
- Потужний, з вбудованим ORM і адмінкою.
- Велика спільнота та документація.

**Мінуси:**
- Вища складність налаштування.
- Менша продуктивність (синхронна природа).
- Надмірний для простих API.

#### FastAPI
**Плюси:**
- Асинхронність і висока швидкодія.
- Простий синтаксис.
- Автоматична документація OpenAPI.
- Сильна типізація (Pydantic).

**Мінуси:**
- Менше розширень, ніж у Flask/Django.

### Рішення
Обрано **FastAPI** — оптимальний вибір за співвідношенням швидкості, простоти та сучасності.  
Експертиза у FastAPI також відповідала вимогам вакансії.

---

## Рішення: Postgres, як основна база даних

### Контекст
Потрібно обрати СУБД для зберігання користувацьких даних.

### Варіанти

#### MySQL
**Плюси:** добра продуктивність, інструменти.  
**Мінуси:** слабша підтримка складних типів, менш гнучка.

#### PostgreSQL
**Плюси:**
- Підтримка UUID, JSON, масивів.
- Потужні транзакції.
- Висока надійність.
- Добра масштабованість і робота з великими даними.

**Мінуси:** складніша конфігурація.

#### SQLite
**Плюси:** легкість.  
**Мінуси:** не підходить для багатокористувацьких і масштабних систем.

### Рішення
Обрано **PostgreSQL** — найкраще рішення для складних, транзакційних і масштабованих мікросервісів.

---

## Рішення: Redis для кешування та управління сесіями

### Контекст
Потрібно швидке та ефективне рішення для кешу та управління сесіями.

### Варіанти

#### Memcached
**Плюси:** простота, швидкість.  
**Мінуси:** немає стійкості даних, обмежені типи.

#### Redis
**Плюси:**
- Складні структури (Hash, List, Set).
- Стійкість і TTL.
- Підтримка сесій, Pub/Sub.

**Мінуси:** складніше налаштування.

#### Сховище у БД
**Плюси:** просто.  
**Мінуси:** навантаження на основну БД, повільніше.

### Рішення
Обрано **Redis** — швидке, надійне та зручне рішення для кешу та управління сесіями.

---

## Рішення: SQLAlchemy для ORM

### Контекст
Потрібно ORM для взаємодії з базою даних.

### Варіанти

#### SQLAlchemy
**Плюси:**
- Потужність і гнучкість.
- Асинхронна підтримка.
- Інтеграція з Alembic.

**Мінуси:** складність для новачків.

#### Tortoise ORM
**Плюси:** асинхронність “з коробки”.  
**Мінуси:** обмежена функціональність.

#### Peewee
**Плюси:** легкість.  
**Мінуси:** недостатня потужність.

### Рішення
Обрано **SQLAlchemy** — професійний інструмент для роботи з БД, з підтримкою async і міграцій.

---

## Рішення: Pydantic для валідації даних
### Контекст
Потрібно забезпечити валідацію та серіалізацію даних у FastAPI.
### Варіанти
#### Marshmallow
**Плюси:** гнучкість.  
**Мінуси:** додатковий шар, не інтегрований з FastAPI.
#### Pydantic
**Плюси:**
- Вбудований у FastAPI.
- Потужна типізація.
- Висока продуктивність.  
**Мінуси:** крива навчання для складних моделей.
### Рішення
Обрано **Pydantic** — ідеально інтегрований з FastAPI, забезпечує швидку валідацію та серіалізацію.

---

## Рішення: aioprometheus для моніторингу

### Контекст
Потрібно збирати метрики продуктивності мікросервісу.

### Варіанти

#### Prometheus + FastAPI Exporter
**Плюси:** популярність, інтеграція.  
**Мінуси:** додаткове налаштування.

#### aioprometheus
**Плюси:** оптимізований під асинхронність, простий.  
**Мінуси:** менше спільноти.

### Рішення
Обрано **aioprometheus** — чудово підходить для асинхронної архітектури FastAPI.

---

## Рішення: csv.DictReader для обробки CSV файлів

### Контекст
Потрібно обробляти CSV у процесі імпорту даних.

### Варіанти

#### pandas
**Плюси:** потужний інструмент.  
**Мінуси:** надмірний для простої обробки.

#### csv.DictReader
**Плюси:** стандартна бібліотека, простота.  
**Мінуси:** обмежений функціонал.

### Рішення
Обрано **csv.DictReader** — мінімалістичне, швидке та ефективне рішення.

---

## Рішення: Pytest для тестування

### Контекст
Потрібен фреймворк для тестування FastAPI-сервісу.

### Варіанти

#### Unittest
**Плюси:** вбудований у Python.  
**Мінуси:** менш гнучкий.

#### Pytest
**Плюси:**
- Потужний і розширюваний.
- Підтримує pytest-asyncio.
- Багато плагінів.

**Мінуси:** потребує встановлення.

### Рішення
Обрано **Pytest** — забезпечує асинхронність і зручність написання тестів.

---

## Рішення: Docker Compose для розгортання

### Контекст
Потрібно організувати запуск мікросервісу з залежностями (Postgres, Redis).

### Варіанти

#### Kubernetes
**Плюси:** масштабування, оркестрація.  
**Мінуси:** складність для локальних проєктів.

#### Docker Compose
**Плюси:**
- Простота конфігурації.
- Зручний локальний деплой.
- Мінімальні ресурси.

**Мінуси:** не підходить для великих кластерів.

### Рішення
Обрано **Docker Compose** — ідеально для локальної розробки і CI-середовищ.

---

## Рішення: JWT для аутентифікації

### Контекст
Потрібен механізм аутентифікації користувачів.

### Варіанти

#### OAuth2
**Плюси:** масштабований, підтримує провайдерів.  
**Мінуси:** складність налаштування.

#### JWT
**Плюси:**
- Безстанна аутентифікація.
- Добра інтеграція з FastAPI.
- Швидкість.

**Мінуси:** потрібна правильна безпека токенів.

#### API-key
**Плюси:** простота.  
**Мінуси:** слабка безпека.

### Рішення
Обрано **JWT** — легкий і безпечний спосіб аутентифікації.  
Для Swagger документації використано OAuth2 для зручності авторизації.

---

## Рішення: Makefile для автоматизації завдань
### Контекст
Потрібно спростити виконання завдань імпорту історичних даних на рівні CLI.
### Варіанти
#### Bash скрипти
**Плюси:** простота.  
**Мінуси:** менш читабельні, складніше підтримувати.
#### Makefile
**Плюси:**
- Читабельність.
- Легкість у використанні.
- Підтримка залежностей між завданнями.
**Мінуси:** потребує знання синтаксису Makefile.
### Рішення
Обрано **Makefile** — забезпечує зручну автоматизацію CLI завдань з імпорту даних.

---

## Рішення: logging для структурованого логування
### Контекст
Потрібно організувати логування для моніторингу та відлагодження.
### Варіанти
#### Стандартний logging
**Плюси:** вбудований, гнучкий.  
**Мінуси:** потребує налаштування для структурованого логування.
#### Loguru
**Плюси:** простота використання, структуроване логування.  
**Мінуси:** додаткова залежність.
### Рішення
Обрано **стандартний logging** з налаштуванням форматування для структурованого логування.  
Це дозволяє уникнути зайвих залежностей та забезпечує гнучкість.

---